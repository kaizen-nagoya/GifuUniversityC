proc4_1.c
/************************************************************************
 例題4-1
 可変抵抗で変化する電圧を取得し，その電圧をLED4ビットで2進数表示するプログラム
*************************************************************************/
// Tera Termを立ち上げて、9600bpsで状態を出力するように機能追加したプログラム
// (c) Dr. Kiyoshi Ogawa

#include <machine.h>
#include "iodefine.h"

/***********************************************************************/
/*                                                                     */
/*  FILE        :SHAKI0003.c                                           */
/*  DATE        :Tue, Sep 02, 2008                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :SH7144F                                               */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.9).     */
/*                                                                     */
/***********************************************************************/
//  Default Clock (12.5MHz) 
//   φ;50MHz,Ｐφ;25MHz
//**********************************************************************
                 
#define TMP_WATTIM  2000000

#include "typedefine.h"            
//#include "iodefine.h" 

void main(void);
void Init_UART(void);
//void Init_ADC(void);
void Put_UART_s(char *);
void Put_UART_c(char );
void Get_UART_c(char *); 
//void Get_ADC(int *);
//
void Itoa(char *,int);
void Itoa2(char *,int , int, int *);
void Strcpy(char *,char *);
void Strcat(char *,char *);
int  Strcmp(char *,char *);
int  Strlen(char *);
int  Strncmp(char *,char *, int);
int  Atoi(char *);
int  adc_data=0; 
int  chg_data=0; 
void init_mtu(void);
void init_ad(void);
char work_line[20];
int  lp; 

void main(void)
{
PFC.PEIORL.BIT.B14 = 1; //PE14を出力に設定
PFC.PEIORL.BIT.B13 = 1; //PE13を出力に設定
PFC.PEIORL.BIT.B12 = 1; //PE12を出力に設定
PFC.PEIORL.BIT.B11 = 1; //PE11を出力に設定

set_imask(0); //割り込みマスクをクリア
init_ad(); //ADコンバータの初期化
init_mtu(); //MTUの初期化

//*************************** 
//  1.初期化
//***************************
// (1)SCIの初期化
    Init_UART(); 

// (2)ADCの初期化
//    Init_ADC(); 

//*************************** 
//  2.メイン処理
//***************************
//  (1)接続メッセージを出力する
    Put_UART_s("SH7144F Connected OK! ");

//  (2)電圧を測定して表示する
    while(1){

}
}

void Init_UART(void)
{
// ******************************************
//  0.SCI1モジュールのスタンバイ解除
//   ※必須なので忘れないように！！！
// ******************************************
    MST.CR1.BIT._SCI1=0;
// ******************************************
//  1.PFCの設定
//    PA3;RXD1,PA4;TXD1に定義する
// ******************************************
//  (1)RXD1(PA3)の定義
    PFC.PACRL2.BIT.PA3MD=1;  
//  (2)TXD1(PA4)の定義
    PFC.PACRL2.BIT.PA4MD=1;  

// ******************************************
//  2.SCIの設定
// ******************************************
//   (0)送受信割込禁止、送受信禁止
    SCI1.SCR.BYTE=0x00;
//   (1)シリアルモードレジスタの設定
//      通信フォーマット、クロックソースを選択
    SCI1.SMR.BYTE=0x00;
//   (2)ビットレートレジスタ(Ｐφ:25MHz, ビットレート:9600）
//      25MHz,9600BPSの時、BRR=(25000000/(32*9600)) - 1 => 80 
    SCI1.BRR=80;
//   (4)シリアルコントロールレジスタ
    SCI1.SCR.BIT.TE=1;  // トランスミットイネーブル:送信動作を許可
    SCI1.SCR.BIT.RE=1;  // レシーブイネーブル:受信動作を許可
    SCI1.SCR.BIT.RIE=0; // 受信割り込み要求を許可
    SCI1.SCR.BIT.TIE=0; // 送信割り込み要求を許可

}


//****************************************************************************
//   Function Name : Put_UART_s
//   Title         : Put Strings
//   Input         :
//   Output        :
//   Description   :
//****************************************************************************
void Put_UART_s(char in_str[])
{
    unsigned int lp=0;
    while(in_str[lp] != 0) {
        Put_UART_c(in_str[lp]);
        lp++;
    }
}


//****************************************************************************
//   Function Name : Put_UART_c
//   Title         : Put Character
//   Input         :
//   Output        :
//   Description   :
//****************************************************************************
void Put_UART_c(char in_c)
{
    while (SCI1.SSR.BIT.TDRE==0);
//
    SCI1.TDR=in_c;
//
    SCI1.SSR.BIT.TDRE=0;
 
}

//****************************************************************************
//   Function Name : Get_UART_c
//   Title         : Get Character
//   Input         :
//   Output        :
//   Description   :
//****************************************************************************
void Get_UART_c(char *out_c) {

//  (1)Check RDRF
    while ((SCI1.SSR.BYTE & 0x40)==0);

//  (2)Get data 
    *out_c = SCI1.RDR;

//  (3)Clear RDRF
    SCI1.SSR.BYTE = SCI1.SSR.BYTE & 0xBF;

}

void int_adi1()
{
//int input;

AD1.ADCSR.BIT.ADF = 0; //AD変換終了フラグのクリア
adc_data = (AD1.ADDR4.WORD >> 6)/(1023/5); //上位10ビットのみ取得
PE.DRL.BYTE.H = (0x78 << adc_data) | (PE.DRL.BYTE.H & 0x87);
//  chg_data = adc_data * 3.3 * 1000 / 1023; 
    chg_data = adc_data;
       Itoa(work_line,chg_data);

//     4)USARTに出力
//        Put_UART_s(" Volt(An0):");
        Put_UART_s(work_line);
//Put_UART_s("[mV]    ");
//     4)タイマー(Wait) 
        for(lp=0;lp<TMP_WATTIM;lp++); 

}

//****************************************************************************
//   Function Name : Strcpy
//   Title         : 
//   Input         : 
//   Output        : 
//   Description   : 
//****************************************************************************
void Strcpy(char out[],char in[])
{
unsigned int lp=0;
    while(in[lp]!=0x00){
        out[lp]=in[lp];
        lp++;
    }
    out[lp]=0x00;
}

//****************************************************************************
//   Function Name : Strlen
//   Title         : 
//   Input         : 
//   Output        : 
//   Description   : 
//****************************************************************************
int Strlen(char in[])
{
unsigned int lp=0;
    while(in[lp]!=0x00)
        lp++;
    return(lp);
}

//****************************************************************************
//   Function Name : Strcat
//   Title         : 
//   Input         : 
//   Output        : 
//   Description   : 
//****************************************************************************
void Strcat(char out[],char in[])
{
unsigned int lp=0,lp1=0;
    while(out[lp1]!=0x00)
        lp1++;
//
    while(in[lp]!=0x00){
        out[lp1]=in[lp];
        lp++;
        lp1++;
    }
    out[lp1]=0x00;
}

//****************************************************************************
//   Function Name : Strncmp
//   Title         : 
//   Input         : 
//   Output        : 
//   Description   : 
//****************************************************************************
int Strncmp(char in1[],char in2[], int len)
{
unsigned int lp=0;

    for(lp=0;lp<len;lp++){
        if(in1[lp] != in2[lp]){
            return(-1);
        }
    }
    return(0);
}

//****************************************************************************
//   Function Name : Strcmp
//   Title         : 
//   Input         : 
//   Output        : 
//   Description   : 
//****************************************************************************
int Strcmp(char in1[],char in2[])
{
unsigned int lp=0;
    while(in1[lp]!=0x00){
        if(in1[lp]!=in2[lp]){
            return(2);
        }
        lp++;
    }
 //
    lp=0;
    while(in2[lp]!=0x00){
        if(in1[lp]!=in2[lp]){
            return(2);
        }
        lp++;
    }
    return(0);
}

//****************************************************************************
//   Function Name : Atoi
//   Title         : 
//   Input         : 
//   Output        : 
//   Description   : 
//****************************************************************************
int Atoi(char in_char[]){
unsigned int lp=0;
int num=0;
char tmp_c;
int tmp_i;
unsigned int pred=1;
int len=0;
int sin=1;

    while(in_char[len]!=0x00)
        len++;
    if(len<1)return(0);
//
    while(in_char[lp] != 0x00){
        tmp_c = in_char[len-1];
        tmp_i = tmp_c & 0x0f;
        if((tmp_c == '-') && (len == 1 )){
            sin = -1;
        }else{
            num = num + tmp_i * pred;
        }
        pred = pred * 10;
        lp++;
        len--;
    }
    num=num*sin;
    return(num);
}

//****************************************************************************
//   Function Name : Itoa
//   Title         : 
//   Input         : 
//   Output        : 
//   Description   : 0 <= in_i < 100000
//****************************************************************************
void Itoa(char out_s[],int in_i)
{
char tmp_c[2];
int  tmp_i;
int  flg=0;

    out_s[0]=0x00;
    
    if(in_i>99999){
        Strcpy(out_s,"99999");
        return;
    }else if(in_i < 0){
        Strcpy(out_s,"*");
        return;
    }
//
    
    if(in_i > 9999 || flg != 0){
        Itoa2(tmp_c,in_i, 10000, &tmp_i);
        Strcat(out_s,tmp_c);
        in_i = in_i - tmp_i * 10000;
        flg=1;
    }
//
    if(in_i > 999 || flg != 0){
        Itoa2(tmp_c,in_i, 1000, &tmp_i);
        Strcat(out_s,tmp_c);
        in_i = in_i - tmp_i * 1000;
        flg=1;
    }
//
    if(in_i > 99 || flg != 0){
        Itoa2(tmp_c,in_i, 100, &tmp_i);
        Strcat(out_s,tmp_c);
        in_i = in_i - tmp_i * 100;
        flg=1;
    }
//
    if(in_i > 9 ||  flg != 0){
        Itoa2(tmp_c,in_i, 10, &tmp_i);
        Strcat(out_s,tmp_c);
        in_i = in_i - tmp_i * 10;
        flg=1;
    }
//
    Itoa2(tmp_c,in_i, 1, &tmp_i);
    Strcat(out_s,tmp_c);
}

void Itoa2(char out_s[],int in_1, int in_2, int *out_i)
{
int tmp_i;
    tmp_i = in_1 / in_2;
    if(tmp_i > 9) tmp_i = 0;
    else if(tmp_i < 0) tmp_i = 0;
    out_s[0] = (char)tmp_i | 0x30;
    out_s[1] = 0x00;
    *out_i = tmp_i;
}

/*!
MTU初期化関数
*/
void init_mtu()
{
MST.CR2.BIT._MTU = 0; //MTUを起動

MTU4.TCR.BIT.CKEG = 0; //立ち上がりエッジ(24MHz)
MTU4.TCR.BIT.CCLR = 1; //TGRAのコンペアマッチでクリア
MTU4.TCR.BIT.TPSC = 0; //P_phi/1(24MHz)でカウント
MTU4.TGRA = 499; //24Mhz / 48kHz = 500
MTU4.TCNT = 0; //カウンタを0に

MTU4.TMDR.BIT.MD = 0;  //通常動作（16ビットタイマー）
MTU4.TIER.BIT.TTGE = 1; //TGRAのコンペアマッチでAD変換開始

MTU.TSTR.BIT.CST4 = 1; //MTU4をスタート
}

/*!
ADコンバータ初期化関数
*/
void init_ad(void)
{
MST.CR2.BIT._AD1 = 0; //AD1を起動

AD1.ADCSR.BIT.ADM = 0; //シングルモード
AD1.ADCSR.BIT.CH = 0; //AN4入力
AD1.ADCSR.BIT.ADIE = 1; //割り込み許可
INTC.IPRG.BIT._AD = 1; //AD割り込みの優先度を1に

AD1.ADCR.BIT.ADCS = 0; //ワンサイクルスキャン
AD1.ADCR.BIT.CKS = 3; //P_phi/4時間で変換
AD1.ADCR.BIT.TRGE = 1; //トリガによる開始は有効

AD1.ADTSR.BIT.TRGS = 2; //MTUトリガ起動を許可
}
